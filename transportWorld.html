<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transport World - Kids Video Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.0.0/dist/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #E0F6FF 50%, #87CEEB 100%);
            font-family: 'Comic Sans MS', cursive, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
            margin-top: 20px;
        }
        
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            z-index: 1000;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        #startButton:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 12px 25px rgba(0,0,0,0.4);
        }
        
        #startButton:active {
            transform: translate(-50%, -50%) scale(0.95);
        }
        
        .hidden {
            display: none !important;
        }
        
        #title {
            color: #2C3E50;
            font-size: 36px;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        #currentScene {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            color: #2C3E50;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 100;
        }
    </style>
</head>
<body>
    <h1 id="title">üöó Transport World üöÇ</h1>
    <p style="color: #2C3E50; text-align: center; margin: 5px;">
        <strong>Instructions:</strong> 1) Choose episode 2) Click "Start Adventure!" 3) Allow audio permissions 4) Watch the animated vehicles!
        <br><small>üéµ Add classic_soft.mp3 to /music/ folder for background music | üí° Open console (F12) for debug info</small>
    </p>
    
    <div style="text-align: center; margin: 10px;">
        <label for="episodeSelect" style="color: #2C3E50; font-weight: bold; margin-right: 10px;">Choose Episode:</label>
        <select id="episodeSelect" style="padding: 8px 15px; font-size: 16px; border-radius: 10px; border: 2px solid #4ECDC4; background: white;">
            <option value="scripts/transport_episode_1.json">üöó Quick Episode (7 vehicles)</option>
            <option value="scripts/transport_episode_complete.json">üé¨ Complete Episode (with music & story)</option>
        </select>
    </div>

    <div id="gameContainer">
        <button id="startButton">‚ñ∂Ô∏è Start Adventure!</button>
        <div id="currentScene" class="hidden">Loading...</div>
    </div>

    <script>
        // ===== GLOBAL VARIABLES =====
        let app;
        let currentScript = null;
        let currentSceneIndex = 0;
        let currentTextIndex = 0;
        let isPlaying = false;
        let vehicleSprite = null;
        let backgroundContainer = null;
        let textDisplay = null;
        let clouds = [];

        // Audio settings
        let backgroundMusic = null;
        let musicLoaded = false;

        // Text-to-Speech settings
        let speechSynth = window.speechSynthesis;
        let currentVoice = null;

        // ===== INITIALIZATION =====
        async function initializeApp() {
            try {
                console.log('üöÄ Initializing PIXI Application...');
                console.log('PIXI version:', PIXI.VERSION);
                
                // Check if PIXI is available
                if (typeof PIXI === 'undefined') {
                    throw new Error('PIXI.js library failed to load');
                }

                // Try modern v8 initialization first
                try {
                    app = new PIXI.Application();
                    
                    await app.init({
                        width: 1200,
                        height: 800,
                        backgroundColor: 0x87CEEB,
                        antialias: true
                    });

                    console.log('‚úÖ PIXI v8 initialization successful');
                } catch (v8Error) {
                    console.log('‚ö†Ô∏è v8 init failed, trying legacy method:', v8Error.message);
                    
                    // Fallback to legacy initialization for older PIXI versions
                    app = new PIXI.Application({
                        width: 1200,
                        height: 800,
                        backgroundColor: 0x87CEEB,
                        antialias: true
                    });
                    
                    console.log('‚úÖ PIXI legacy initialization successful');
                }

                // Add canvas to container - check both possible canvas references
                const canvas = app.canvas || app.view;
                if (!canvas) {
                    throw new Error('No canvas element found in PIXI application');
                }

                document.getElementById('gameContainer').appendChild(canvas);
                console.log('‚úÖ Canvas added to DOM');

                // Setup background
                createBackground();

                // Setup voice
                setupVoice();

                // Setup background music
                setupBackgroundMusic();

                // Add start button event
                document.getElementById('startButton').addEventListener('click', startPresentation);

                console.log('üéÆ Transport World initialized successfully!');
            } catch (error) {
                console.error('‚ùå Error initializing PIXI:', error);
                
                // Show error message to user
                const errorMsg = document.createElement('div');
                errorMsg.innerHTML = `
                    <div style="color: red; text-align: center; padding: 20px; background: rgba(255,255,255,0.9); border-radius: 10px; margin: 20px;">
                        <h3>‚ö†Ô∏è Error Loading Graphics Engine</h3>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p>Please try:</p>
                        <ul style="text-align: left;">
                            <li>Refresh the page (F5 or Ctrl+R)</li>
                            <li>Check your internet connection</li>
                            <li>Try a different browser (Chrome, Firefox, Safari)</li>
                            <li>Disable ad blockers temporarily</li>
                        </ul>
                        <button onclick="location.reload()" style="padding: 10px 20px; margin-top: 10px; cursor: pointer;">üîÑ Refresh Page</button>
                    </div>
                `;
                document.getElementById('gameContainer').appendChild(errorMsg);
            }
        }

        // ===== BACKGROUND SETUP =====
        function createBackground() {
            backgroundContainer = new PIXI.Container();
            app.stage.addChild(backgroundContainer);

            // Create gradient background
            const gradient = new PIXI.Graphics();
            gradient.beginFill(0x87CEEB);
            
            // Use renderer dimensions for compatibility
            const width = app.renderer?.width || app.screen?.width || 1200;
            const height = app.renderer?.height || app.screen?.height || 800;
            
            gradient.drawRect(0, 0, width, height);
            gradient.endFill();
            backgroundContainer.addChild(gradient);

            // Create animated clouds
            createClouds();

            console.log('üå§Ô∏è Background created with animated clouds');
        }

        function createClouds() {
            const cloudCount = 5;
            
            for (let i = 0; i < cloudCount; i++) {
                const cloud = new PIXI.Graphics();
                
                // Draw cloud shape
                cloud.beginFill(0xFFFFFF, 0.7);
                cloud.drawCircle(0, 0, 40);
                cloud.drawCircle(35, 0, 30);
                cloud.drawCircle(-35, 0, 30);
                cloud.drawCircle(15, -20, 25);
                cloud.drawCircle(-15, -20, 25);
                cloud.endFill();

                // Position clouds randomly
                cloud.x = Math.random() * app.screen.width;
                cloud.y = 50 + Math.random() * 200;
                cloud.scale.set(0.5 + Math.random() * 0.5);

                backgroundContainer.addChild(cloud);
                clouds.push({
                    sprite: cloud,
                    speed: 0.2 + Math.random() * 0.3
                });
            }

            // Animate clouds
            app.ticker.add(animateClouds);
        }

        function animateClouds() {
            clouds.forEach(cloud => {
                cloud.sprite.x += cloud.speed;
                
                // Reset cloud position when it goes off screen
                if (cloud.sprite.x > app.screen.width + 100) {
                    cloud.sprite.x = -100;
                    cloud.sprite.y = 50 + Math.random() * 200;
                }
            });
        }

        // ===== BACKGROUND MUSIC SETUP =====
        function setupBackgroundMusic() {
            try {
                console.log('üéµ Setting up background music...');
                
                // Create audio element for background music
                backgroundMusic = new Audio();
                backgroundMusic.preload = 'auto';
                backgroundMusic.loop = true;
                backgroundMusic.volume = 0.3; // Quiet background music for narration clarity
                
                // Set up event listeners
                backgroundMusic.addEventListener('canplaythrough', () => {
                    console.log('‚úÖ Background music loaded and ready');
                    musicLoaded = true;
                });
                
                backgroundMusic.addEventListener('error', (e) => {
                    console.warn('‚ö†Ô∏è Background music failed to load:', e);
                    musicLoaded = false;
                });

                backgroundMusic.addEventListener('ended', () => {
                    console.log('üéµ Background music ended, restarting...');
                    if (isPlaying) {
                        backgroundMusic.currentTime = 0;
                        backgroundMusic.play().catch(e => console.warn('Music restart failed:', e));
                    }
                });

                // We'll load the actual music file when script is loaded
                console.log('üéµ Background music system ready');
                
            } catch (error) {
                console.error('‚ùå Error setting up background music:', error);
                musicLoaded = false;
            }
        }

        async function loadBackgroundMusic(musicPath) {
            if (!backgroundMusic || !musicPath) {
                console.warn('‚ö†Ô∏è No background music or path specified');
                return false;
            }

            try {
                console.log(`üéµ Loading background music: ${musicPath}`);
                
                // Set the source
                backgroundMusic.src = musicPath;
                
                // Try to load the music
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Music loading timeout'));
                    }, 5000); // 5 second timeout

                    backgroundMusic.addEventListener('canplaythrough', () => {
                        clearTimeout(timeout);
                        resolve();
                    }, { once: true });

                    backgroundMusic.addEventListener('error', (e) => {
                        clearTimeout(timeout);
                        reject(e);
                    }, { once: true });

                    backgroundMusic.load();
                });

                musicLoaded = true;
                console.log('‚úÖ Background music loaded successfully');
                return true;

            } catch (error) {
                console.warn('‚ö†Ô∏è Could not load background music:', error.message);
                musicLoaded = false;
                return false;
            }
        }

        function startBackgroundMusic() {
            if (!backgroundMusic || !musicLoaded) {
                console.warn('‚ö†Ô∏è Background music not available');
                return;
            }

            try {
                backgroundMusic.currentTime = 0;
                const playPromise = backgroundMusic.play();
                
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('üéµ Background music started');
                        })
                        .catch(error => {
                            console.warn('‚ö†Ô∏è Background music play failed (user interaction required):', error);
                            // This is normal - browsers require user interaction before audio can play
                        });
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error starting background music:', error);
            }
        }

        function stopBackgroundMusic() {
            if (backgroundMusic && !backgroundMusic.paused) {
                backgroundMusic.pause();
                console.log('üéµ Background music stopped');
            }
        }

        // ===== VOICE SETUP =====
        function setupVoice() {
            // Wait for voices to load
            if (speechSynth.getVoices().length === 0) {
                speechSynth.addEventListener('voiceschanged', selectBestVoice);
            } else {
                selectBestVoice();
            }
        }

        function selectBestVoice() {
            const voices = speechSynth.getVoices();
            
            // Prefer child-friendly English voices
            const preferredVoices = [
                'Google UK English Female',
                'Microsoft Zira - English (United States)',
                'Alex',
                'Samantha',
                'Victoria'
            ];

            for (let preferred of preferredVoices) {
                currentVoice = voices.find(voice => voice.name.includes(preferred));
                if (currentVoice) break;
            }

            // Fallback to any English voice
            if (!currentVoice) {
                currentVoice = voices.find(voice => voice.lang.startsWith('en'));
            }

            console.log('üé§ Voice selected:', currentVoice?.name || 'Default');
        }

        // ===== SCRIPT LOADING =====
        async function loadScript() {
            try {
                // Get selected episode from dropdown
                const episodeSelect = document.getElementById('episodeSelect');
                const selectedEpisode = episodeSelect.value;
                
                console.log('üìú Loading episode:', selectedEpisode);
                
                const response = await fetch(selectedEpisode);
                if (!response.ok) {
                    throw new Error(`Failed to load script: ${response.status}`);
                }
                currentScript = await response.json();
                console.log('üìú Script loaded:', currentScript.title);

                // Load background music if specified
                if (currentScript.background_music) {
                    console.log('üéµ Loading background music from script...');
                    await loadBackgroundMusic(currentScript.background_music);
                }

                return true;
            } catch (error) {
                console.error('‚ùå Error loading script:', error);
                const episodeSelect = document.getElementById('episodeSelect');
                const selectedEpisode = episodeSelect.value;
                alert(`Could not load the episode script: ${selectedEpisode}. Please check that the file exists.`);
                return false;
            }
        }

        // ===== PRESENTATION CONTROL =====
        async function startPresentation() {
            if (isPlaying) return;

            console.log('üöÄ User clicked Start Adventure!');

            // Show loading state
            document.getElementById('startButton').textContent = '‚è≥ Loading...';
            document.getElementById('startButton').style.background = 'linear-gradient(45deg, #95a5a6, #7f8c8d)';

            // Load script
            const scriptLoaded = await loadScript();
            if (!scriptLoaded) {
                document.getElementById('startButton').textContent = '‚ùå Error - Try Again';
                document.getElementById('startButton').style.background = 'linear-gradient(45deg, #e74c3c, #c0392b)';
                setTimeout(() => {
                    document.getElementById('startButton').textContent = '‚ñ∂Ô∏è Start Adventure!';
                    document.getElementById('startButton').style.background = 'linear-gradient(45deg, #FF6B6B, #4ECDC4)';
                }, 2000);
                return;
            }

            // Hide start button and show scene indicator
            document.getElementById('startButton').classList.add('hidden');
            document.getElementById('currentScene').classList.remove('hidden');

            isPlaying = true;
            currentSceneIndex = 0;

            // Start background music
            startBackgroundMusic();
            
            console.log('üé¨ Starting presentation with', currentScript.scenes.length, 'scenes');
            playCurrentScene();
        }

        async function playCurrentScene() {
            if (!currentScript || currentSceneIndex >= currentScript.scenes.length) {
                endPresentation();
                return;
            }

            const scene = currentScript.scenes[currentSceneIndex];
            console.log(`üé≠ Playing scene: ${scene.id} (type: ${scene.type || 'vehicle'})`);

            // Update scene indicator
            const sceneLabel = scene.object || scene.type || 'Scene';
            document.getElementById('currentScene').textContent = 
                `Scene ${currentSceneIndex + 1}/${currentScript.scenes.length}: ${sceneLabel}`;

            // Handle different scene types
            if (scene.type === 'music_only') {
                // Music-only scene - no vehicle, just wait
                console.log('üéµ Music-only scene');
                const duration = scene.duration || 2000;
                setTimeout(() => {
                    currentSceneIndex++;
                    playCurrentScene();
                }, duration);
                return;
            }

            if (scene.type === 'announcement' || scene.type === 'review' || scene.type === 'finale') {
                // Text-only scenes without vehicles
                console.log('üì¢ Announcement/Review scene');
                
                // Clear previous vehicle
                if (vehicleSprite) {
                    app.stage.removeChild(vehicleSprite);
                    vehicleSprite = null;
                }

                // Play text lines for this scene
                currentTextIndex = 0;
                playNextLine(scene);
                return;
            }

            if (scene.type === 'group_scene') {
                // Show multiple vehicles or special group scene
                console.log('üë• Group scene');
                
                // For now, treat as announcement - can be enhanced later
                if (vehicleSprite) {
                    app.stage.removeChild(vehicleSprite);
                    vehicleSprite = null;
                }

                currentTextIndex = 0;
                playNextLine(scene);
                return;
            }

            // Regular vehicle scene
            // For hide_seek scenes, keep the existing vehicle if it's the same object
            const previousScene = currentScript.scenes[currentSceneIndex - 1];
            const shouldKeepVehicle = scene.id && scene.id.includes('hide_seek') && 
                                    vehicleSprite && 
                                    scene.object;
            
            console.log('üîÑ Vehicle persistence check:');
            console.log('  - Current scene:', scene.id, 'object:', scene.object);
            console.log('  - Previous scene:', previousScene?.id, 'object:', previousScene?.object);
            console.log('  - Has vehicleSprite:', !!vehicleSprite);
            console.log('  - Should keep vehicle:', shouldKeepVehicle);

            if (!shouldKeepVehicle) {
                // Clear previous vehicle only if not a continuing hide_seek scene
                if (vehicleSprite) {
                    app.stage.removeChild(vehicleSprite);
                    vehicleSprite = null;
                }

                // Create vehicle sprite from image
                if (scene.image) {
                    await createVehicleSprite(scene);
                }
            } else {
                console.log('üîÑ Keeping existing vehicle for hide_seek scene');
            }

            // Play text lines for this scene
            currentTextIndex = 0;
            playNextLine(scene);
        }

        async function createVehicleSprite(scene) {
            try {
                console.log(`üñºÔ∏è Loading image for: ${scene.object}`);
                
                // Get the image path from the scene data
                const imagePath = scene.image;
                
                if (!imagePath) {
                    console.warn(`‚ö†Ô∏è No image path found for ${scene.object}, using fallback`);
                    createFallbackGraphic(scene.object);
                    return;
                }

                console.log(`üìÅ Loading: ${imagePath}`);

                // Load the image using PIXI Assets
                let texture;
                try {
                    texture = await PIXI.Assets.load(imagePath);
                    console.log(`‚úÖ Image loaded successfully: ${imagePath}`);
                } catch (imageError) {
                    console.warn(`‚ö†Ô∏è Failed to load image ${imagePath}, trying SVG fallback:`, imageError.message);
                    // Try SVG fallback
                    const svgPath = imagePath.replace('.png', '.svg');
                    try {
                        texture = await PIXI.Assets.load(svgPath);
                        console.log(`‚úÖ SVG fallback loaded: ${svgPath}`);
                    } catch (svgError) {
                        console.error(`‚ùå Both PNG and SVG failed for ${scene.object}:`, svgError.message);
                        createFallbackGraphic(scene.object);
                        return;
                    }
                }

                // Create sprite from loaded texture
                vehicleSprite = new PIXI.Sprite(texture);
                
                // Set anchor to center for proper positioning and rotation
                vehicleSprite.anchor.set(0.5);
                
                // Scale the sprite to appropriate size (smaller, more reasonable size)
                const targetWidth = 120; // Smaller size - more appropriate for kids content
                const scale = targetWidth / vehicleSprite.width;
                vehicleSprite.baseScale = scale; // Store base scale for animations
                
                // Position vehicle
                vehicleSprite.x = app.screen.width / 2;
                vehicleSprite.y = app.screen.height / 2 + 50;
                vehicleSprite.scale.set(0); // Start invisible for animation

                app.stage.addChild(vehicleSprite);
                console.log(`üé≠ Vehicle sprite created and added to stage: ${scene.object}`);

                // Animate vehicle entrance
                animateVehicleEntrance();
                
            } catch (error) {
                console.error(`‚ùå Error creating vehicle sprite:`, error);
                createFallbackGraphic(scene.object);
            }
        }

        function createFallbackGraphic(vehicleType) {
            console.log(`üé® Creating fallback graphic for: ${vehicleType}`);
            
            // Create a simple colored rectangle as fallback
            const graphics = new PIXI.Graphics();
            
            // Vehicle-specific colors
            const colors = {
                'car': 0xFF6B6B,
                'bus': 0xFFD93D,
                'train': 0x6BCF7F,
                'airplane': 0x4ECDC4,
                'police car': 0x4D79FF,
                'fire truck': 0xFF4757,
                'ambulance': 0xFFFFFF
            };

            const color = colors[vehicleType] || 0xFF6B6B;
            
            // Draw simple vehicle shape
            graphics.beginFill(color);
            graphics.lineStyle(3, 0x2C3E50);
            graphics.drawRoundedRect(-100, -40, 200, 80, 10);
            graphics.endFill();
            
            // Add simple details
            graphics.beginFill(0x74B9FF);
            graphics.drawRoundedRect(-60, -25, 120, 25, 5);
            graphics.endFill();

            vehicleSprite = graphics;
            vehicleSprite.baseScale = 1; // Store base scale for animations
            vehicleSprite.x = app.screen.width / 2;
            vehicleSprite.y = app.screen.height / 2 + 50;
            vehicleSprite.scale.set(0);

            app.stage.addChild(vehicleSprite);
            animateVehicleEntrance();
        }

        function animateVehicleEntrance() {
            if (!vehicleSprite) return;

            console.log('üé¨ Starting vehicle entrance animation');

            // Start off-screen to the left
            vehicleSprite.x = -200;
            vehicleSprite.scale.set(0.1);
            vehicleSprite.rotation = -0.2;

            // Animate to center with dramatic effect
            const targetX = app.screen.width / 2;
            const finalScale = vehicleSprite.baseScale || 1;
            const duration = 1500; // Longer duration for more visible animation
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use different easing for different properties
                const bounceProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                const slideProgress = progress < 0.7 ? progress / 0.7 : 1; // Slide in first 70%
                
                // Slide in from left
                vehicleSprite.x = -200 + (targetX + 200) * slideProgress;
                
                // Scale up with bounce - use correct final scale
                const maxScale = progress < 0.8 ? finalScale * 1.2 : finalScale * (1.2 - (progress - 0.8) * 1); // Overshoot then settle to correct size
                vehicleSprite.scale.set(0.1 + (maxScale - 0.1) * bounceProgress);
                
                // Rotate to upright
                vehicleSprite.rotation = -0.2 + (0.2 * bounceProgress);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Final bounce settle - use correct base scale
                    vehicleSprite.scale.set(finalScale);
                    vehicleSprite.rotation = 0;
                    vehicleSprite.x = targetX;
                    console.log('‚úÖ Vehicle entrance animation complete, scale:', finalScale);
                }
            };

            animate();
        }

        function animateVehicleExit(callback) {
            if (!vehicleSprite) {
                if (callback) callback();
                return;
            }

            console.log('üé¨ Starting vehicle exit animation');

            // Get current position and scale
            const startX = vehicleSprite.x;
            const startScale = vehicleSprite.scale.x;
            const targetX = app.screen.width + 200; // Exit to the right
            const duration = 1500; // Same duration as entrance
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easing for smooth exit
                const easeProgress = Math.pow(progress, 2); // Ease in quadratic - starts slow, speeds up
                
                // Slide out to the right
                vehicleSprite.x = startX + (targetX - startX) * easeProgress;
                
                // Scale down slightly as it exits
                vehicleSprite.scale.set(startScale * (1 - progress * 0.3));
                
                // Slight rotation as it exits
                vehicleSprite.rotation = progress * 0.2;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    console.log('‚úÖ Vehicle exit animation complete');
                    if (callback) callback();
                }
            };

            animate();
        }

        function playNextLine(scene) {
            if (currentTextIndex >= scene.text.length) {
                console.log('üìã Scene completed, moving to next scene');
                
                // Variable timing based on scene type for better flow
                let sceneDelay = 1500; // Default
                if (scene.type === 'music_only') {
                    sceneDelay = 500; // Quick transition for music
                } else if (scene.type === 'announcement' || scene.type === 'review') {
                    sceneDelay = 1000; // Medium delay for text scenes  
                } else if (scene.object) {
                    sceneDelay = 1800; // Longer delay for vehicle scenes
                }
                
                setTimeout(() => {
                    currentSceneIndex++;
                    playCurrentScene();
                }, sceneDelay);
                return;
            }

            const text = scene.text[currentTextIndex];
            console.log(`üó£Ô∏è Speaking line ${currentTextIndex + 1}/${scene.text.length}: "${text}"`);

            // Update scene indicator to show current text
            const sceneLabel = scene.object || scene.type || 'Scene';
            document.getElementById('currentScene').textContent = 
                `${sceneLabel.toUpperCase()}: "${text}" (${currentTextIndex + 1}/${scene.text.length})`;

            // Handle special interactions based on text content - only if we have a vehicle
            const textLower = text.toLowerCase();
            console.log('üîç Checking text:', text, 'vehicleSprite exists:', !!vehicleSprite, 'scene.object:', scene.object);
            
            if (textLower.includes('where is') && vehicleSprite && scene.object) {
                // Before asking "where is", hide the vehicle
                console.log('üôà Hiding vehicle for "where is" question:', text);
                hideVehicleBehindClouds(() => {
                    speak(text, () => {
                        currentTextIndex++;
                        setTimeout(() => playNextLine(scene), 1500); // Longer pause for suspense
                    });
                });
            } else if (textLower.includes('here is') && vehicleSprite && scene.object) {
                // For "here is", reveal the vehicle dramatically
                console.log('üé≠ Revealing vehicle for "here is" answer');
                revealVehicleFromClouds(() => {
                    speak(text, () => {
                        console.log('‚úÖ Speech completed, starting idle animation');
                        if (vehicleSprite) {
                            addVehicleIdleAnimation();
                        }
                        currentTextIndex++;
                        setTimeout(() => playNextLine(scene), 800);
                    });
                });
            } else if (textLower.includes('goodbye') && vehicleSprite && scene.object) {
                // For "goodbye", make the vehicle exit off screen
                console.log('üëã Vehicle saying goodbye - animating exit');
                speak(text, () => {
                    console.log('‚úÖ Goodbye speech completed, starting exit animation');
                    animateVehicleExit(() => {
                        currentTextIndex++;
                        setTimeout(() => playNextLine(scene), 500);
                    });
                });
            } else {
                // Normal speech for other lines
                speak(text, () => {
                    console.log('‚úÖ Speech completed');
                    if (vehicleSprite && scene.object && !vehicleSprite.isHiding) {
                        console.log('üé≠ Starting idle animation');
                        addVehicleIdleAnimation();
                    }
                    currentTextIndex++;
                    
                    // Variable timing based on content
                    let speechDelay = 800;
                    if (text.toLowerCase().includes('goodbye')) {
                        speechDelay = 1200; // Longer pause for goodbyes
                    } else if (scene.type === 'review') {
                        speechDelay = 600; // Faster for lists
                    }
                    
                    setTimeout(() => playNextLine(scene), speechDelay);
                });
            }
        }

        function addVehicleIdleAnimation() {
            if (!vehicleSprite) return;

            console.log('üé≠ Starting vehicle idle animation');

            // More visible floating and breathing animation
            const baseY = vehicleSprite.y;
            const baseScale = vehicleSprite.baseScale || vehicleSprite.scale.x; // Use stored base scale
            let animationTime = 0;

            const animate = () => {
                if (!vehicleSprite || !isPlaying || vehicleSprite.isHiding) return;

                animationTime += 0.02;
                
                // Floating motion (up and down)
                const floatOffset = Math.sin(animationTime * 2) * 15; // Increased amplitude
                vehicleSprite.y = baseY + floatOffset;
                
                // Gentle breathing effect (scale)
                const scaleOffset = Math.sin(animationTime * 1.5) * 0.05;
                vehicleSprite.scale.set(baseScale + scaleOffset);
                
                // Slight rotation sway
                const rotationOffset = Math.sin(animationTime * 1.8) * 0.03;
                vehicleSprite.rotation = rotationOffset;

                requestAnimationFrame(animate);
            };

            animate();
        }

        // ===== HIDE AND SEEK ANIMATIONS =====
        function hideVehicleBehindClouds(onComplete) {
            if (!vehicleSprite) {
                console.warn('‚ö†Ô∏è No vehicle sprite to hide');
                if (onComplete) onComplete();
                return;
            }

            console.log('üå§Ô∏è Vehicle hiding behind clouds...');

            // Create a natural fluffy cloud like the background clouds
            const hidingCloud = new PIXI.Graphics();
            hidingCloud.beginFill(0xFFFFFF, 0.8); // Same opacity as background clouds
            
            // Create a moderately sized cloud - just enough to hide vehicle
            hidingCloud.drawCircle(0, 0, 65);      // Main body
            hidingCloud.drawCircle(50, 0, 50);     // Right puff
            hidingCloud.drawCircle(-50, 0, 50);    // Left puff  
            hidingCloud.drawCircle(30, -35, 40);   // Top right
            hidingCloud.drawCircle(-30, -35, 40);  // Top left
            hidingCloud.drawCircle(0, -50, 30);    // Top center
            hidingCloud.drawCircle(20, 30, 25);    // Bottom right
            hidingCloud.drawCircle(-20, 30, 25);   // Bottom left
            hidingCloud.endFill(); // No borders - clean like background clouds

            // Position cloud off-screen initially
            hidingCloud.x = app.screen.width + 150; // Fixed offset for cloud positioning
            hidingCloud.y = vehicleSprite.y;

            // Ensure cloud is on top of vehicle by adding it after the vehicle
            // and setting a higher z-index if needed
            app.stage.addChild(hidingCloud);
            
            // Make sure cloud is in front by reordering
            const vehicleIndex = app.stage.getChildIndex(vehicleSprite);
            app.stage.setChildIndex(hidingCloud, vehicleIndex + 1);
            
            console.log('‚òÅÔ∏è Natural hiding cloud added in front of vehicle');

            // Animate cloud moving in to cover vehicle
            const duration = 1200; // Slightly longer for better effect
            const startTime = Date.now();
            const startX = hidingCloud.x;
            const targetX = vehicleSprite.x;

            const animateCloudIn = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out

                hidingCloud.x = startX + (targetX - startX) * easeProgress;

                // Stop vehicle idle animation while hiding
                vehicleSprite.isHiding = true;

                if (progress < 1) {
                    requestAnimationFrame(animateCloudIn);
                } else {
                    // Vehicle is now completely hidden behind cloud
                    console.log('üôà Vehicle successfully hidden behind natural cloud');
                    
                    // Store cloud reference for later removal
                    vehicleSprite.hidingCloud = hidingCloud;
                    
                    if (onComplete) onComplete();
                }
            };

            animateCloudIn();
        }

        function revealVehicleFromClouds(onComplete) {
            if (!vehicleSprite) {
                console.warn('‚ö†Ô∏è No vehicle sprite to reveal');
                if (onComplete) onComplete();
                return;
            }

            console.log('üéâ Vehicle revealing from behind clouds...');

            const hidingCloud = vehicleSprite.hidingCloud;
            if (!hidingCloud) {
                console.log('‚ö†Ô∏è No hiding cloud found, skipping reveal animation');
                // Clear hiding state anyway
                vehicleSprite.isHiding = false;
                if (onComplete) onComplete();
                return;
            }

            // Dramatic reveal: vehicle bounces out while cloud moves away
            const duration = 1400; // Slightly longer for better dramatic effect
            const startTime = Date.now();
            const vehicleStartX = vehicleSprite.x;
            const vehicleTargetX = app.screen.width / 2; // Back to center
            const cloudStartX = hidingCloud.x;
            const cloudTargetX = -300; // Move cloud further off-screen

            const animateReveal = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Different easing for vehicle and cloud
                const bounceProgress = progress < 0.7 ? 
                    1 - Math.pow(1 - (progress / 0.7), 2) : // Ease out quad for first 70%
                    1 + (Math.sin((progress - 0.7) * 15) * 0.15 * (1 - progress)); // Bounce effect for last 30%
                
                const cloudProgress = 1 - Math.pow(1 - progress, 2); // Ease out quad

                // Move vehicle back to center with dramatic bounce
                vehicleSprite.x = vehicleStartX + (vehicleTargetX - vehicleStartX) * bounceProgress;
                
                // Add dramatic scale effect during reveal - more pronounced
                const scaleEffect = 1 + (Math.sin(progress * Math.PI * 1.5) * 0.3);
                const currentScale = vehicleSprite.baseScale || 1;
                vehicleSprite.scale.set(Math.max(currentScale * scaleEffect, currentScale * 0.8)); // Don't let it get too small

                // Move cloud away faster
                hidingCloud.x = cloudStartX + (cloudTargetX - cloudStartX) * cloudProgress;
                
                // Fade out cloud more gradually at first, then faster
                const fadeProgress = progress < 0.5 ? progress * 0.4 : 0.2 + (progress - 0.5) * 1.6;
                hidingCloud.alpha = Math.max(0, 1 - fadeProgress);

                if (progress < 1) {
                    requestAnimationFrame(animateReveal);
                } else {
                    // Clean up
                    const finalScale = vehicleSprite.baseScale || 1;
                    vehicleSprite.scale.set(finalScale); // Reset to proper scale
                    vehicleSprite.x = vehicleTargetX; // Ensure final position
                    vehicleSprite.isHiding = false; // Clear hiding state
                    
                    // Remove hiding cloud completely
                    if (hidingCloud.parent) {
                        hidingCloud.parent.removeChild(hidingCloud);
                    }
                    vehicleSprite.hidingCloud = null;

                    console.log('üé≠ Vehicle successfully revealed with dramatic effect!');
                    if (onComplete) onComplete();
                }
            };

            animateReveal();
        }

        // ===== TEXT-TO-SPEECH =====
        function speak(text, onComplete) {
            // Cancel any ongoing speech
            speechSynth.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            
            // Configure voice settings for kids
            if (currentVoice) {
                utterance.voice = currentVoice;
            }
            utterance.rate = 0.8; // Slower for kids
            utterance.pitch = 1.1; // Slightly higher pitch
            utterance.volume = 0.8;

            utterance.onend = () => {
                console.log('‚úÖ Speech completed');
                if (onComplete) onComplete();
            };

            utterance.onerror = (event) => {
                console.error('‚ùå Speech error:', event.error);
                if (onComplete) onComplete();
            };

            speechSynth.speak(utterance);
        }

        // ===== PRESENTATION END =====
        function endPresentation() {
            console.log('üéâ Presentation completed!');
            isPlaying = false;

            // Stop background music
            stopBackgroundMusic();

            // Show celebration animation
            showCelebration();

            // Reset UI
            setTimeout(() => {
                document.getElementById('startButton').classList.remove('hidden');
                document.getElementById('currentScene').classList.add('hidden');
                document.getElementById('startButton').textContent = 'üîÑ Play Again!';
                
                // Clear vehicle
                if (vehicleSprite) {
                    app.stage.removeChild(vehicleSprite);
                    vehicleSprite = null;
                }
            }, 3000);
        }

        function showCelebration() {
            // Create celebratory elements
            const celebration = new PIXI.Container();
            app.stage.addChild(celebration);

            // Create confetti
            for (let i = 0; i < 20; i++) {
                const confetti = new PIXI.Graphics();
                const colors = [0xFF6B6B, 0x4ECDC4, 0xFFD93D, 0x6BCF7F, 0x4D79FF];
                confetti.beginFill(colors[Math.floor(Math.random() * colors.length)]);
                confetti.drawRect(0, 0, 10, 10);
                confetti.endFill();

                confetti.x = Math.random() * app.screen.width;
                confetti.y = -50;
                confetti.rotation = Math.random() * Math.PI * 2;

                celebration.addChild(confetti);

                // Animate confetti falling
                const fallSpeed = 2 + Math.random() * 3;
                const rotationSpeed = (Math.random() - 0.5) * 0.2;

                const animateConfetti = () => {
                    confetti.y += fallSpeed;
                    confetti.rotation += rotationSpeed;

                    if (confetti.y < app.screen.height + 50) {
                        requestAnimationFrame(animateConfetti);
                    }
                };

                setTimeout(() => animateConfetti(), Math.random() * 1000);
            }

            // Add celebration text
            const celebText = new PIXI.Text('Great Job! üéâ', {
                fontFamily: 'Arial',
                fontSize: 48,
                fill: 0x2C3E50,
                fontWeight: 'bold',
                stroke: 0xFFFFFF,
                strokeThickness: 4
            });

            celebText.anchor.set(0.5);
            celebText.x = app.screen.width / 2;
            celebText.y = app.screen.height / 2 - 100;
            celebText.scale.set(0);

            celebration.addChild(celebText);

            // Animate celebration text
            let scale = 0;
            const animateText = () => {
                scale += 0.05;
                celebText.scale.set(Math.min(scale, 1));
                
                if (scale < 1) {
                    requestAnimationFrame(animateText);
                }
            };
            animateText();

            // Remove celebration after delay
            setTimeout(() => {
                app.stage.removeChild(celebration);
            }, 3000);
        }

        // ===== STARTUP =====
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üìÑ DOM loaded, initializing application...');
            initializeApp().catch(error => {
                console.error('‚ùå Failed to initialize app:', error);
            });
        });

        /*
        ===== NOTES FOR DEVELOPERS =====
        
        ASSET PLACEMENT:
        - Place vehicle images in: assets/vehicles/
          Examples: car.png, bus.png, train.png, airplane.png, police_car.png, fire_truck.png, ambulance.png
        
        - Place background music in: music/
          Example: classic_soft.mp3
        
        - Animation files (if using spine/lottie): assets/vehicles/
          Examples: car_anim.json, bus_anim.json, etc.
        
        CUSTOMIZATION:
        - To change voices: Modify the preferredVoices array in selectBestVoice()
        - To adjust speech speed: Change utterance.rate (0.5-2.0)
        - To change scene timing: Modify timeout values in playNextLine()
        - To add new vehicles: Update vehicleConfigs in createVehicleSprite()
        
        REPLACING PLACEHOLDER GRAPHICS:
        - Replace createVehicleSprite() with PIXI.Loader to load actual images
        - Add proper sprite animation using PIXI.AnimatedSprite for moving parts
        - Consider using Spine animations for more complex vehicle movements
        
        ADDING BACKGROUND MUSIC:
        - Uncomment and implement background music loading
        - Use PIXI.sound or HTML5 Audio API
        - Ensure music loops and has appropriate volume for narration
        
        FUTURE ENHANCEMENTS:
        - Add interactive elements (click to repeat words)
        - Include sound effects for each vehicle
        - Add different backgrounds per scene
        - Implement scene transitions (slide, fade, etc.)
        - Add subtitles option
        - Include multiple language support
        */
        
    </script>
</body>
</html>